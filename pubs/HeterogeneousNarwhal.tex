\documentclass{article}
\usepackage{markdown}
\usepackage{soulutf8}
%\renewcommand{\st}[1]{}
%\usepackage[scale=.75]{geometry}
\usepackage{placeins}
\usepackage{amsthm,amssymb,hyperref,marginnote}
\usepackage{subfig}
\usepackage{enotez}
\setenotez{counter-format=Alph}
\usepackage[textsize=footnotesize]{luatodonotes}%\usepackage{todonotes}%
\usepackage{xcolor}
\newcommand{\nb}[1]{%
  \todo[color=blue!60!black,shadow]{NB:\\ #1}%
}

\usepackage{newunicodechar}
\input{UnicodeReplacements.tex}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\usepackage{amsmath}
% \usepackage[T1]{fontenc}
% \usepackage{lmodern}
%\usepackage[utf8]{inputenc}
\usepackage{xspace}
% macros
\newcommand{\tnote}[1]{
  \marginnote{\footnotesize #1}%
}
\newcommand{\rtnote}[1]{%
  \reversemarginpar%
  \tnote{#1}%
  \normalmarginpar%
}

\newcommand{\base}[1][ ]{%
  base ledger%
  \ifthenelse{\equal{#1}{ }}{}{#1}
}
\newcommand{\Base}[1][ ]{%
  Base ledger
  \ifthenelse{\equal{#1}{ }}{}{#1}
}

% \dag is defined to produce † unfortunately
\newcommand{\DAG}[1][]{\textsc{Dag}#1\xspace}
\newcommand{\Dag}[1][]{\textsc{dag}#1\xspace}

\newcommand{\fifo}{\textsc{fifo}}
\newcommand{\Fifo}{\textsc{Fifo}}
\newcommand{\aka}[1][]{a.k.a.\xspace}
\newcommand{\ie}[1][]{\emph{i.e.}, }
\newcommand{\eg}[1][]{\emph{e.g.}, }
\newcommand{\fig}[1][]{Fig.~}
\newcommand{\Learner}{%
  % the set of learners
  \ensuremath{L}
}
\newcommand{\Q}[1]{%
  % trust live
  Q_{#1}%
}
\newcommand{\rough}[1][ ]{%
  %\fbox{\color{blue!70!black}!!}%
  \ifthenelse{\equal{#1}{ }}%
  {{\color{red}{\bf!!}}}%
  {{\color{blue!70!black}\ul{#1}}}%
}
\newcommand{\circledX}[1]{\tikz[baseline={(x.south)}]{\node[circle,draw,inner sep=.3pt,outer sep=0pt,very thin](x){\tiny #1};}}
\usepackage{newunicodechar}
%\newunicodechar{}{\ensuremath{}}  
\newunicodechar{₁}{\ensuremath{{}_1}}
\newunicodechar{₂}{\ensuremath{{}_2}}
\newunicodechar{₃}{\ensuremath{{}_3}}
\newunicodechar{₄}{\ensuremath{{}_4}}
\newunicodechar{₅}{\ensuremath{{}_5}}
\newunicodechar{★}{\ensuremath{*}~}
\newunicodechar{ }{~}
%\newunicodechar{①}{\circledX 1}
\newunicodechar{“}{``}
\newunicodechar{”}{''}
%\newunicodechar{②}{\circledX 2}
\newunicodechar{ₐ}{\ensuremath{{}_a}}
\newunicodechar{ₚ}{\ensuremath{{}_p}}
\newunicodechar{‼}{\rough}
\newunicodechar{‽}{\ensuremath{?!}}
\newunicodechar{↑}{\ensuremath{\uparrow}}  
\newunicodechar{⇑}{\ensuremath{\Uparrow}}  
\newunicodechar{♯}{\ensuremath{\sharp%\hat\#
}}  
\newunicodechar{∅}{\ensuremath{\varnothing}}
\newunicodechar{≠}{\ensuremath{\neq}}              
\newunicodechar{∩}{\ensuremath{\cap}}              
\newunicodechar{≡}{\ensuremath{\equiv}}              
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{ℝ}{\ensuremath{\mathbb{R}}}
\newunicodechar{↔}{\ensuremath{\leftrightarrows}}    
\newunicodechar{→}{\ensuremath{\rightarrow}}
\newunicodechar{←}{\ensuremath{\leftarrow}}
\newunicodechar{⇒}{\ensuremath{\Rightarrow}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{‌}{\allowbreak }
\newunicodechar{‍}{{}}                                

\usepackage{tikzpeople}%‼ for evil validators etc. 

\usepackage{tikz}
\usetikzlibrary{shapes,positioning,fit,backgrounds}
\usetikzlibrary{patterns,intersections,calc}
\newcommand{\qs}[1][~]{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[rectangle,
,double,inner sep=.5pt,outer sep=0pt,fill=black] (theNode){\textcolor{white}{\footnotesize \bf q#1}};}
}
\newcommand{\bk}[1][green!60!black]{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[regular polygon, regular polygon sides=6
,double,inner sep=.5pt,outer sep=0pt,fill=#1] (theNode){\textcolor{white}{\footnotesize \bf bk}};}}
\newcommand{\ac}{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[regular polygon, regular polygon sides=6
,double,inner sep=.5pt,outer sep=0pt,fill=black] (theNode){\textcolor{white}{\footnotesize \bf a}};}}

\newcommand{\hd}[1][ ]{%
  \ifthenelse{\equal{#1}{}}%
  {\tikz[baseline={([yshift=0pt]theNode.base)}]{
      \node[rectangle,inner sep=1.5pt,outer sep=0pt,double] (theNode){\textcolor{black}{\footnotesize \bf \ul{HD}}};
    }}%
  {\tikz[baseline={([yshift=0pt]theNode.base)}]{
      \node[rectangle,double,inner sep=1.5pt,outer sep=0pt,double,draw] (theNode){\textcolor{black}{\footnotesize \bf HD}};
      
    }}%
}
\newcommand{\wh}[1][ ]{%
  \tikz[baseline={([yshift=0pt]theNode.base)}]{%
    \ifthenelse{\equal{#1}{ }}%
    {\node[rectangle,fill=black,inner sep=1.5pt,outer sep=0pt] (theNode){\textcolor{white}{\footnotesize \bf WH}};}%
    {\node[rectangle,draw,fill=lightgray,inner sep=1.5pt,outer sep=0pt] (theNode){\textcolor{black}{\footnotesize  WH}};}%
  }%
}

\newcommand{\anItemInline}[6][theNode]{%
  % #1 the name of the node (just in case, remember picture is on)
  % #2 shape (e.g., ellipse)
  % #3 fill color (e.g., black)
  % #4 draw color (e.g., green, or none)
  % #5 text color (e.g., white)
  % #6 the actual text (e.g., \bf TX)
  \tikz[baseline={([yshift=0pt]#1.base)},remember picture]{%
    \node[#2,fill=#3,draw=#4,inner sep=.5pt,outer sep=0pt] %
    (#1){%
      \textcolor{#5}{%
        \footnotesize #6%
      }%
    };%
  }%
  % additional “decorations” via another pic, 
  % (with `remember picture` and `overlay`)
}

\newcommand{\tx}[1][theTX]{%
  \anItemInline[#1]%
  {ellipse}%
  {black}%
  {none}%
  {white}%
  {\bf TX}%
}
% \newcommand{\tx}[1][]{%
%   \tikz[baseline={([yshift=0pt]theNode.base)}]{%
%     \node[ellipse,fill=black,inner sep=.5pt,outer sep=0pt] %
%     (theNode){%
%       \textcolor{white}{\footnotesize \bf TX\makebox[0pt][l]{\ensuremath{{}_{#1}}}}};%
%   }%
% }
\newcommand{\es}{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[ellipse,fill=white,draw,thick,inner sep=.5pt,outer sep=0pt] (theNode){\textcolor{black}{\footnotesize TX}};}}
\newcommand{\rnd}{\ensuremath{\mathrm{rnd}}}
\newcommand{\cnt}{\ensuremath{\mathrm{cnt}}}
% \usepackage{ebgaramond}
% \usepackage[cmintegrals,cmbraces]{newtxmath}
% \usepackage{ebgaramond-maths}
% \usepackage{amssymb}
\usepackage{fontspec}
% \setmainfont{Asana-Math}

%https://tex.stackexchange.com/questions/425098/which-opentype-math-fonts-are-available
\usepackage{comment}
%\includecomment{comment}
\let\oldendnote\endnote
\renewcommand{\endnote}[2][]{%
  \marginnote{\oldendnote[#1]{#2}}%
}
\title{leftoevers of heterogeneous narwhal}

\author{Tobias Heindel}
\begin{document}

\section{food for thought}
\subsection{new}



\subsubsection{some of Tobias' brainstorming}
how can we make chimera chains safer?

\begin{description}
\item[Requirement candidates]~\\
  \begin{itemize}
  \item
    \emph{absolutism:}
    if 
    a transfer between two base ledgers is commited in 
    a “healthy” chimera chain, 
    then the transfer is also (essentially) commited in both ledgers
    \endnote{%
      Here, the question arises,
      if a potential roll-back in case of 
    },
    i.e., eventually it will go through, unless we've got a “liveness fault”
    \todo{whatever a liveness fault is}
  \item 
    \emph{justified absolutism:}
    each consensus on an anchor block selection in 
    a chimera chain needs “double consensus” from both chains,
    i.e., 
    effectiverly,
    both chains need to approve the anchor block,
    which might lead to liveness issues ? 
    
  \item
    \emph{absolutism grounding:}
    does each anchor block in the chimera chain
    have also references to blocks in the underlying chain, 
    “super-supporting” the anchor?

  \item
    \emph{user authorization:}
    users may choose to effectively use
    the chimera chain as a limited bridge,
    “temporariliy” moving (some of their accounts)
    to the chimera chain
    \todo{%
      what's the difference to the bridge then here?%
    }
  \item
    \emph{user's ruling:}
    moving assets into other chains
    -- e.g., chimera but not necessarily --
    for atomic settlement on the other chain

    
  \end{itemize}
\end{description}


\subsection{old}

\subsubsection{}


\begin{itemize}
\item
  lots of state is completely independent of each other, 
  can we use this for optimization using this ``concurrency''
\item 
  how does this state right tool work ? 
\item 
  How do the message graphs of HP
  compare to Narwhal DAGs
\end{itemize}
\paragraph{Isaac's thoughts}

\begin{itemize}
\item message sharing (on the primary level) might be slow
\item 
\end{itemize}

\href{%
https://github.com/anoma/specs/blob/main/src/architecture/consensus/typhon/mempool.md%
}{the specs}

\subsection{very old, but ... very researchy}

\paragraph{is reliable broadcast in narwhal actually even more useful?}
does Narwhal make consensus easier
in that it restricts the set of valid values to propose?
In particular,
proposals of non-existing blocks are impossible?
cf. ideas in
\href{https://www.sciencedirect.com/science/article/pii/089054018790054X}{Asynchronous Byzantine agreement protocols}


\paragraph{what can be gained by randomness? at what price?}

well, just for the record,
this is an interesting venue for (much) more performance,
which is probably much harder to analyze ... 
\begin{itemize}
\item \href{https://link.springer.com/article/10.1007/s10009-020-00603-x}{Verification of randomized consensus algorithms under round-rigid adversaries}
\item \emph{Randomized Byzantine Generals} Michael O.~Rabin,  1983
\end{itemize}





\section{specific questions}
\begin{itemize}
\item 
  “availability certificate Availability Certificate: an aggregation of signatures from a Weak Quorum attesting that everything referenced by a particular Header is available. \bf Must include a signature from the Header's primary.”
  \begin{itemize}
  \item
\begin{verbatim}
Where is this signature?
\end{verbatim}
  \item
\begin{verbatim}
What does it sign?
\end{verbatim}




  \end{itemize}
\item my acknowledgment, “Availability Vote” --
\begin{verbatim}
isn't it rather a **promise/pledge**
\end{verbatim}
\item about ``blocks'' 
\begin{verbatim}
does it make sense to call these learner blocks, possibly even certified learner blocks?
\end{verbatim}
\item about \tx{s}: 
\begin{verbatim}
  a learner might actually ignore a big chuck of transactions?
\end{verbatim}
\item about the ``two'' protocols
\begin{verbatim}
 if the integrity protocol gets stuck, 
 the availability protocol will stuck?
\end{verbatim}
yes
\begin{verbatim}
   also vice versa ? 
\end{verbatim}
partially 

\item more about blocks
\begin{verbatim}
headers have "sequence numbers" (stemming from the creator)
\end{verbatim}

\item about signed quorum
\begin{verbatim}
would it make sense to call these 
signed_certified learner blocks_
\end{verbatim}
  


\begin{verbatim}
WHEN ARE BLOCKS broadcast and by whom?! 
\end{verbatim}
\color{green!60!black}
it *is* a broadcast and it is performed
\begin{itemize}
\item after completion (in analogy to availability certificates)
\item by the block creator 
\end{itemize}

\end{itemize}

---
\section{Random snippets}

\begin{itemize}
\item Besides the learner graph,
we assume that each transaction is relevant only to a subset of the learners.%
\endnote{%
  \emph{Does it make sense to have transactions that no learner subscribes to?}
  Probaly not! Garbage collection could be triggered by 
}
\ 
\item 
\end{itemize}

---

\begin{description}
\item[New header construction and broadcast] 
  \tnote{primary\\ ⇒ primary}
  The following conditions will trigger the production of a new header.

  \begin{itemize}
  \item
    Each worker on the primary's validator has provided a
    worker has for the validators current round. 
  \item If not genesis round,
    ... %‼ certificate of availability of it's own previous header / block
  \item 
    If not genesis round,
    ...%‼ signed quorum 
  \end{itemize}

  Once, 
  the header is constructed \textcolor{violet}{(but NOT signed?)}, %‼ 
  the primary broadcasts it to all other primaries. 

\item[Header checking and acknowledgment (Availability Vote)]
  A received header of a primary is checked, 
  according to the following check list. 
  
  \begin{itemize}
  \item
    The worker hashes of the header must have been “uploaded”
    by the local workers
    (which are trusted to have check theses worker hashes).
    
  \item If not genesis round,
    ... %‼ certificate of availability of it's own previous header / block
  \item 
    If not genesis round,
    ...%‼ signed quorum 
  \end{itemize}

  After checking all this,
  the primary sents an acknowledment back to the header producer, 
  \ie a message with the header signed. 


\item[Availability Certificate generation and broadcast]
  \tnote{primary\\ ⇒ ∀primary}
  After receiving a global weak quorum of header acknowledments 
  for a previously broadcast header, 
  the received signatures are aggreagated
  \textcolor{violet}{\bf and singed}. %‼ 

  The result is broadcast to all primaries. 

\item[Waiting for (certified learner) blocks]
  \fbox{\color{violet}confusing switch to integrity protocol!}

\item[Announcing signed quorums]
  Once a validator has enough 
  “fresh” blocks (see below) for a learner from a “preceeding” round, 
  the primary signs a learner-specific quorum of such blocks.
  However,
  under certain conditions,
  it might be useful to anounce \emph{empty} signed quorums, 
  indicating that the next block header will not include 
  any signed quorums for a specific learner. 
\end{description}

\subsection{Primary actions in the integrity protocol}
\label{sec:prim-acti-integr}

\begin{enumerate}

\item[Uniqueness attestation / Integrity Vote]
  \tnote{primary\\ → primary}  
  When a primary receives a header from another validator
  with a round number that directly succeeds 
  the last known header of the sending validator, 
  ‼[(for a new \emph{“round”})] %
  the primary signs that header (additionally for the purpose of integerity)
  and sends it back to the creator of the header.

  \color{violet}\item[Certified learner blocks (Integrity certificate for headers)]
  \color{violet}
  \tnote{primary\\ ⇒ primary}
  Upon receiving a learner-specific quorum of integriy votes for a header, 
  the primary aggregates these
  and broadcasts a certied learner block. 

\item[Signed block quorums]
  
  
  


\end{enumerate}


\subsubsection{Genesis round}

\begin{description}
\item[Header compilation]
  \tnote{primary → primary}
  Whenever a full set of worker hashes from another validator
  has ,
  the primary 
  
\end{description}

---

\paragraph{learner-specific round numbers}

\begin{itemize}
\item Each learner might “observe” different round numbers. 
\item In first approximation: do not expect any synchrony whatsoever!
\end{itemize}


\paragraph{reference a quorum of blocks from the previous round}
This is seen as follows,
(for non-genesis blocks):

\begin{itemize}
\item the block contains a header \hd
\item 
\end{itemize}

\paragraph{learner-specific DAG structure}

\section{Erasure coding}
The worker that has received a transaction from a client
    generates a suitable erasure code,
    broken up into a finite set of shares%
    \footnote{%
      Shares are also known as \emph{chunks}.%
    }%
    \
    to be distributed over all validators. 
    The share distribution has to be such that
    %“
    any quorum of validators (relative to any learner)%
    \endnote{Here, we want to put
    “(relative to any learner \emph{that subscribes to the transaction})”})
    can re-construct the transaction data %
    %”
    from the set of shares 
    that they obtained collectively. %
    %‼ Discuss and give specific example 
    {‼[check this:]\color{red}
    Moreover, 
    the map from 
    erasure coding shares of the transaction
    to (mirror) workers that receive the respective share
    is determined by the worker's index
    (and the identifier of its validator). 
    \todo{\tiny
      %‼ 
      cf. knowing whether we have all the shares ?
    }
    }

\section{State partition and fractal instances}
\label{sec:state-partition}
Learners,
\eg execution engines,
want to be responsible for
\emph{changes} to the smallest possible part of the state.
However,
to enable basic actions such as cross-chain transfers, 
learners have to gather enough information 
about the global state to determine whether 
a given transaction \tx is actually ‼[valid / executable]. 
The matter becomes delicate
if a transaction depends on parts of the state 
that different learners are responsible for. 
No learner can single-handedly determine if
a given commited transaction is executable, 
unless some learner is tracking the complete global state\xspace% 
---an almost impossible task already our days!
Now,
let us focus on transactions whose “inputs” (or “outputs”) are spread out 
over several learners%
\st{ as these are the trouble makers}%
.

\todo[prepend,inline, caption={On chimera chains}]{%
  
★ ``lock'' the relevant parts of the state on all involved learners
\footnote{%
  footnotes in \texttt{\textbackslash todo} notes
  have to be \texttt{\textbackslash protect}ed, 
  unless we put a caption. 
}
 \\
 ★ ``spawn'' a chimera chain\\
 ★ ``move'' locked state fragments to chimera chain\\
 ★ ``settle'' on chimera chain\\
 ★ ``finalize'' chimera chain\\
 ★ ``re-import projected state''
}
% Howevever,
% the validity of a transaction can depend on 
% parts of the state, 
% which lie outside the area of primary interest. 
We assume that each transition carries enough information 
to instantly deduce which part of the global state is accessed,
possibly distinguishing between reading and writing. 

\section{Old Intro}

\paragraph{Motivation%
\endnote{%
  Paragraph 1: Motivation.
  At a high level, 
  what is the problem area you are working in and why is it important? 
  It is important to set the larger context here. 
  Why is the problem of interest and importance to 
  the larger community?
}%
}
Bridges%
\st{ suck} %
have been the source of sorrow in the past. 
Even if they do work as intended, 
at best, they connect a single pair of chains. 
Building bridges between every pair of chains
is ‼[expensive]. %
Moreover, 
we want that any number of participants,
holding assets on several \emph{different} ledgers\endnote{%
    - base chains
    - root chains
    - ledgers 
} to ‼[“interact” “directly”].
\todo{explain “interact” “directly”}
%\newcommand{\dl}[1][]{\textsc{dl}#1\xspace}(\dl[s])
\todo[inline]{
  argumentation flaw:
  if we have a base ledger count of~\(n\), 
  we will have a quadratic number of chimera chains as well,
  i.e., (at least) one learner for each chimera chain. 
}
\paragraph{Probblem statement%
  \endnote{%
    Paragraph 2:
    What is the specific problem considered in this paper? 
    This paragraph narrows down the topic area of the paper. 
    In the first paragraph you have established general context and importance.
    Here you establish specific context and background. 
  }%
}
‼[
\tt How to enable any number of actors to interact directly
with moderate ressource consumption and suitable latency, 
us-ing only a “minimal” number validators on the involved base ledgers.
%
]
The ideal solution would be 
the atomic execution of a single transaction that
makes reference to all invovled base ledgers.%
\footnote{%
  This assumes counterparty discovery 
  before the transaction  is crafted.
}%
\xspace
Can we operate a protocol
that strikes a good compromise between
the number of validators necessary to order (and execute) transactions,
not spending more ressources than complete pair-wise bridging?

{
  \Huge the above does not cut it
}

\section{Some ideas for how to explain things}

\subsubsection{The risky fast track}
\label{sec:fast-n-furious}

The opposite extreme consists in
not updating any (liveness) quorums
and just hoping for “enough” overlap 
of assumed to be live quorums:
however,
it might be the case
that the intersections do 
not hold enough honest validators.
In the extreme,
none.

\subsubsection{First assessment in view of validator overlap}
\label{sec:assessment-i}

In view of a large overlap,
note that both scenarios gain in practicability:
if every pair of vaildator quorums
has a large overlap,
the increase in communication complexity is mitigated.
Similarly,
for the fast track, 
if overlaps are of validator quorums are big enough,
we have a good chance to have at least 
one correct validator in their intersection.\endnote{%
  research question:
  can we add randomization \emph{orthogonally},
  i.e.,
  without changing the original algorithms
  of heterogeneous narwhal / paxos
}

\subsubsection{Growing the overlap}
\label{sec:growing-the-overlap}

A natural question is how one could go 
about getting a bigger overlap between two chains,
for the sake of additional safety. 
In fact,
one could imagine some sort of 
“auditing” nodes,
which make it harder for Byzantine validators
to trigger safety violations \cite[opodis20HPaxos].



\subsection{Tobias's corner}

\subsubsection{excerpting the %
  \href{https://anoma.net/blog/heterogeneous-paxos-and-multi-chain-atomic-commits/}{%
    blog post%
  }
}
\label{sec:blog-post-excerpts}

\paragraph{The intuitive goal}

combo block

\begin{verbatim}
    [rb]
    /  \ 
  [r]  [b]
   |    |
   |    |
  [r]  [b]
   |    |
   |    |
  [r]  [b]
   |    |
\end{verbatim}

s.t.

\begin{quote}
  both [chains, r\&b,] agree to [unanimously] choose or [jointly] ignore the combo block.
\end{quote}

\begin{quote}
  Fortunately, 
  when there is a lot of overlap between
  validator sets of different chains, 
  these assumptions can become very reasonable.
\end{quote}

\begin{quote}
  within \emph{same} consensus
\end{quote}
\todo{undefined}

\begin{quote}
  bisimulate
\end{quote}
\todo{clashes with bisimulation ‽}

\begin{quote}
  \textbf{It's Kind of Like a Bridge}

  In some ways, 
  our Heterogeneous Consensus could create something like 
  a trusted bridge: 
  it allows operations across multiple chains,
  under specific trust assumptions. 
  Other bridge designs tend to be based on multi-phase commits,
  so ours will be faster and will not require locking assets.
\end{quote}

\begin{quote}
  green quorum is sufficient to make green chain decide on a block without communicating with anyone else
\end{quote}
\todo{%
  now,
  a quorum suddenly seems independent of the green learner
 }

 \begin{quote}
   Note that this would not be a problem if every red quorum had an intersection (featuring an honest participant) with every green quorum: red and green could avoid deciding contradictory things.
 \end{quote}
 \todo{check: 
   there's no global weak quorum
   and heterogeneous narwhal does not help either ?
 }

 \begin{quote}
    Fortunately, we have some promising directions for solving this conundrum.
  \end{quote}
  \todo{e.g., ?}

\begin{quote}
    anyone following only blue transactions or only red transactions will not observe the fork
\end{quote}
\todo{unobserved forks: 
  sounds terrible‼
}

  \begin{quote}
  "move state" from, say, the purely blue chain to the blue-green chain when they want to do business with green smart contracts, and then back to the blue chain when they're done.
\end{quote}
\todo{
  how ?
  this sounds very much like a bridge,
  and does not solve the game theoretic problem?
}

\begin{quote}
  Each piece of state (each smart contract) needs application-specific code to decide which chain holds its lock at which time.
\end{quote}
\todo{
  how to keep track of this ``locking table'' 
}
\begin{quote}
  trusted by chains
\end{quote}

\begin{quote}
  the transactions are actually executed together
\end{quote}
\todo{
  well,
  something like all execution engines do it (eventually?)
}

\begin{quote}
  prove what messages are sent
\end{quote}
\todo{
  proving what messages are sent \emph{by whom?}
  users, validators, others, …
}
\subsubsection{On the %
  \href{https://anoma.net/blog/heterogeneous-paxos-and-multi-chain-atomic-commits/}{%
    blog post%
  }
}
\label{sec:blog-post-discussion}

\paragraph{Could we merge chains into chimera chains?}

in other words,
why would we at all want to “split” again?

\begin{verbatim}
  [r]  [b]
   |    |
   |    |
  [r]  [b]
    \  / 
    [rb]
    /  \ 
  [r]  [b]
   |    |
   |    |
  [r]  [b]
   |    |
   |    |
  [r]  [b]
   |    |
\end{verbatim}

\paragraph{random questions}

\subparagraph{not all learners equal, in yet a different way}

there are two very different type of learners:
\begin{itemize}
\item end-users: small stake, non-critical
\item execution engines of validators: high stake, critical
\end{itemize}




\subparagraph{on immediate finality}
which finality do we actually need ?

\subparagraph{drawing on eigenlayer functionality?}
can we

\subparagraph{what about dynamic graphs?}
all of
\begin{itemize}
\item validator sets  
\item assumptions 
\item learner sets
\end{itemize}
can change

cf.
\begin{quote}
   Changing Quorums
\end{quote}

\subparagraph{who can initiate chimera chains / dynamic graphs?}
\begin{description}
\item[rig up] 
\item[tear down] 
\end{description}

\subparagraph{%
  on locks, not really, but ... 
}
what about garbage collection trigger 
for logged mempools




\paragraph{open issues}
Here is an open list of topics to clarify;
in principle, 
these could be in the form of github issues\todo{ (to be discussed)}. 

\subparagraph{certificates for honest behaviour}
examples, what's missing?

\subparagraph{evidence for dishonest behaviour}
examples, what's missing?

\subparagraph{garbage collection}
\begin{itemize}
\item to do or not to do
\item how to do / how to avoid 
\end{itemize}

\subparagraph{It's gonna be better than all bridges out there ‼}
the connection to bridges has to be spelled out \emph{explicitly},
in excrutiating detail

\subparagraph{different perspectives}
the difficulty in describing---and understanding---Tʏᴘʜᴏɴ
are the different perspectives that one has to keep in mind at each point in mind
\begin{itemize}
\item learner(s)
\item validators / participants / workers
\item designer
\item attacker
\item transaction batches ‽
\item chains ‽
\item something else ?
\end{itemize}
Thus, for every sentence, 
one might get it wrong,
if it is not clear who's perspective we are taking. 


\subparagraph{what's shared batch looking like anywy?}

\subparagraph{moving state}
this is a phrase, 
which begs the questions
\begin{itemize}
\item who is moving the state?
\item how is state partitioned?
\end{itemize}

Leaving the capability to move state with the user
is also an extra task the user must be willing to perform. 

\subparagraph{“As Locks”}

\texttt{chains as holding exclusive locks on state}

this model transfers to “user's rule”





\subparagraph{one of those statements to ponder about}

\begin{quote}
  This would allow applications to "move data" to shared chains where atomic commits are possible, and then back. What we need is a specific interface indicating when such moves are safe, when atomicity in batches is preserved, and a way to easily move state from one chain to another.
\end{quote}





\subparagraph{best case scenario}
great
\begin{markdown}
  - that is a good example of quorums
  - dosn't explain why atomic commit is possible
\end{markdown}
\subparagraph{\texttt{Shared batch} of transactions}
now,
what's a shared batch anyway?
a batch of transactions in a combo block ?




\begin{itemize}
\item 
  do chimeara chains need to acquire and release “ownership” ?

  \begin{itemize}
  \item 
  \end{itemize}

\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
